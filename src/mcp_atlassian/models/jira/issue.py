\"\"\"\nJira issue models.\n\nThis module provides Pydantic models for Jira issues.\n\"\"\"\n\nimport logging\nimport re\nfrom typing import Any, Literal\n\nfrom pydantic import Field\n\nfrom ..base import ApiModel, TimestampMixin\nfrom ..constants import (\n    EMPTY_STRING,\n    JIRA_DEFAULT_ID,\n    JIRA_DEFAULT_KEY,\n)\nfrom .comment import JiraComment\nfrom .common import (\n    JiraAttachment,\n    JiraChangelog,\n    JiraIssueType,\n    JiraPriority,\n    JiraResolution,\n    JiraStatus,\n    JiraTimetracking,\n    JiraUser,\n)\nfrom .link import JiraIssueLink\nfrom .project import JiraProject\n\nlogger = logging.getLogger(__name__)\n\n# Extended epic field name patterns to support more variations\nEPIC_NAME_PATTERNS = [\n    r\"epic\\s*name\",\n    r\"epic[._-]?name\",\n    r\"epicname\",\n]\n\nEPIC_LINK_PATTERNS = [\n    r\"epic\\s*link\",\n    r\"epic[._-]?link\",\n    r\"Parent Link\",\n    r\"parent\\s*link\",\n    r\"epiclink\",\n]\n\n\nclass JiraIssue(ApiModel, TimestampMixin):\n    \"\"\"\n    Model representing a Jira issue.\n\n    This is a comprehensive model containing all the common fields\n    for Jira issues and related metadata.\n    \"\"\"\n\n    id: str = JIRA_DEFAULT_ID\n    key: str = JIRA_DEFAULT_KEY\n    summary: str = EMPTY_STRING\n    description: str | dict[str, Any] | None = None\n    created: str = EMPTY_STRING\n    updated: str = EMPTY_STRING\n    status: JiraStatus | None = None\n    issue_type: JiraIssueType | None = None\n    priority: JiraPriority | None = None\n    assignee: JiraUser | None = None\n    reporter: JiraUser | None = None\n    labels: list[str] = Field(default_factory=list)\n    components: list[str] = Field(default_factory=list)\n    comments: list[JiraComment] = Field(default_factory=list)\n    attachments: list[JiraAttachment] = Field(default_factory=list)\n    timetracking: JiraTimetracking | None = None\n    url: str | None = None\n    epic_key: str | None = None\n    epic_name: str | None = None\n    fix_versions: list[str] = Field(default_factory=list)\n    custom_fields: dict[str, Any] = Field(default_factory=dict)\n    requested_fields: Literal[\"*all\"] | list[str] | None = None\n    project: JiraProject | None = None\n    resolution: JiraResolution | None = None\n    duedate: str | None = None\n    resolutiondate: str | None = None\n    parent: dict | None = None\n    subtasks: list[dict] = Field(default_factory=list)\n    security: dict | None = None\n    worklog: dict | None = None\n    changelogs: list[JiraChangelog] = Field(default_factory=list)\n    issuelinks: list[JiraIssueLink] = Field(default_factory=list)\n\n    def __getattribute__(self, name: str) -> Any:\n        \"\"\"\n        Custom attribute access to handle custom field access.\n\n        This allows accessing custom fields by their name as if they were\n        regular attributes of the JiraIssue class.\n\n        Args:\n            name: The attribute name to access\n\n        Returns:\n            The attribute value or custom field value\n        \"\"\"\n        # First try to get the attribute normally\n        try:\n            return super().__getattribute__(name)\n        except AttributeError:\n            # If the attribute doesn't exist, check if it's a custom field\n            try:\n                custom_fields = super().__getattribute__(\"custom_fields\")\n                if name in custom_fields:\n                    return custom_fields[name]\n            except AttributeError:\n                pass\n            # Re-raise the original AttributeError\n            raise\n\n    @property\n    def page_content(self) -> str | None:\n        \"\"\"\n        Get the page content from the description.\n\n        This is a convenience property for treating Jira issues as documentation pages.\n\n        Returns:\n            The description text or None\n        \"\"\"\n        if isinstance(self.description, dict):\n            # Fallback to string representation of ADF for now\n            # In the future, we could parse ADF content here\n            return str(self.description)\n        return self.description\n\n    @staticmethod\n    def _find_custom_field_in_api_response(\n        fields: dict[str, Any], name_patterns: list[str]\n    ) -> Any:\n        \"\"\"\n        Find a custom field by name patterns in the raw API response.\n\n        Used during object creation from API response to extract fields\n        before the JiraIssue object is instantiated.\n\n        Args:\n            fields: The fields dictionary from the Jira API\n            name_patterns: List of field name patterns to search for\n\n        Returns:\n            The custom field value or None\n        \"\"\"\n        if not fields or not isinstance(fields, dict):\n            return None\n\n        # Normalize all patterns for easier matching\n        normalized_patterns = []\n        for pattern in name_patterns:\n            norm_pattern = pattern.lower()\n            norm_pattern = re.sub(r\"[_\\-\\s]\", \"\", norm_pattern)\n            normalized_patterns.append(norm_pattern)\n\n        custom_field_id = None\n\n        # Check if fields has a names fields\n        names_dict = fields.get(\"names\", {})\n        if isinstance(names_dict, dict):\n            for field_id, field_name in names_dict.items():\n                field_name_norm = re.sub(r\"[_\\-\\s]\", \"\", field_name.lower())\n                for norm_pattern in normalized_patterns:\n                    if norm_pattern in field_name_norm:\n                        custom_field_id = field_id\n                        break\n                if custom_field_id:\n                    break\n        else:\n            logger.debug(\"No names dict found in fields\", exc_info=True)\n\n        # Look at field metadata if name method didn't work\n        if not custom_field_id:\n            schema = fields.get(\"schema\", {})\n            if schema and isinstance(schema, dict) and \"fields\" in schema:\n                schema_fields = schema[\"fields\"]\n                if isinstance(schema_fields, dict):\n                    for field_id, field_info in schema_fields.items():\n                        if not field_id.startswith(\"customfield_\"):\n                            continue\n\n                        if isinstance(field_info, dict) and \"name\" in field_info:\n                            field_name = field_info[\"name\"].lower()\n                            field_name_norm = re.sub(r\"[_\\-\\s]\", \"\", field_name)\n                            for norm_pattern in normalized_patterns:\n                                if norm_pattern in field_name_norm:\n                                    custom_field_id = field_id\n                                    break\n\n                        if custom_field_id:\n                            break\n\n        # Try direct matching of field IDs for common epic fields\n        if not custom_field_id:\n            has_epic_link_pattern = any(\"epiclink\" in p for p in normalized_patterns)\n            has_epic_name_pattern = any(\"epicname\" in p for p in normalized_patterns)\n\n            if has_epic_link_pattern:\n                for field_id in fields:\n                    if field_id.startswith(\"customfield_\") and field_id.endswith(\"14\"):\n                        custom_field_id = field_id\n                        break\n            elif has_epic_name_pattern:\n                for field_id in fields:\n                    if field_id.startswith(\"customfield_\") and field_id.endswith(\"11\"):\n                        custom_field_id = field_id\n                        break\n\n        # Last attempt - look through all custom fields for names in their values\n        if not custom_field_id:\n            for field_id, field_value in fields.items():\n                if not field_id.startswith(\"customfield_\"):\n                    continue\n\n                field_name = None\n                if isinstance(field_value, dict) and \"name\" in field_value:\n                    field_name = field_value.get(\"name\", \"\").lower()\n                elif isinstance(field_value, dict) and \"key\" in field_value:\n                    field_name = field_value.get(\"key\", \"\").lower()\n\n                if not field_name:\n                    continue\n\n                field_name_norm = re.sub(r\"[_\\-\\s]\", \"\", field_name)\n                for norm_pattern in normalized_patterns:\n                    if norm_pattern in field_name_norm:\n                        custom_field_id = field_id\n                        break\n\n                if custom_field_id:\n                    break\n\n        if custom_field_id and custom_field_id in fields:\n            return fields[custom_field_id]\n\n        return None\n\n    @classmethod\n    def from_api_response(cls, data: dict[str, Any], **kwargs: Any) -> \"JiraIssue\":\n        \"\"\"\n        Create a JiraIssue from a Jira API response.\n\n        Args:\n            data: The issue data from the Jira API\n            **kwargs: Additional arguments to pass to the constructor\n\n        Returns:\n            A JiraIssue instance\n        \"\"\"\n        if not data:\n            return cls()\n\n        # Handle non-dictionary data by returning a default instance\n        if not isinstance(data, dict):\n            logger.debug(\"Received non-dictionary data, returning default instance\")\n            return cls()\n\n        fields = data.get(\"fields\", {})\n        if not isinstance(fields, dict):\n            fields = {}\n\n        # Get required simple fields\n        issue_id = str(data.get(\"id\", JIRA_DEFAULT_ID))\n        key = str(data.get(\"key\", JIRA_DEFAULT_KEY))\n        summary = str(fields.get(\"summary\", EMPTY_STRING))\n        description = fields.get(\"description\")\n\n        # Timestamps\n        created = str(fields.get(\"created\", EMPTY_STRING))\n        updated = str(fields.get(\"updated\", EMPTY_STRING))\n\n        # Extract assignee data\n        assignee = None\n        assignee_data = fields.get(\"assignee\")\n        if assignee_data:\n            assignee = JiraUser.from_api_response(assignee_data)\n\n        # Extract reporter data\n        reporter = None\n        reporter_data = fields.get(\"reporter\")\n        if reporter_data:\n            reporter = JiraUser.from_api_response(reporter_data)\n\n        # Extract status data\n        status = None\n        status_data = fields.get(\"status\")\n        if status_data:\n            status = JiraStatus.from_api_response(status_data)\n\n        # Extract issue type data\n        issue_type = None\n        issue_type_data = fields.get(\"issuetype\")\n        if issue_type_data:\n            issue_type = JiraIssueType.from_api_response(issue_type_data)\n\n        # Extract priority data\n        priority = None\n        priority_data = fields.get(\"priority\")\n        if priority_data:\n            priority = JiraPriority.from_api_response(priority_data)\n\n        # Extract project data\n        project = None\n        project_data = fields.get(\"project\")\n        if isinstance(project_data, dict):\n            project = JiraProject.from_api_response(project_data)\n\n        resolution = None\n        resolution_data = fields.get(\"resolution\")\n        if isinstance(resolution_data, dict):\n            resolution = JiraResolution.from_api_response(resolution_data)\n\n        duedate = (\n            fields.get(\"duedate\") if isinstance(fields.get(\"duedate\"), str) else None\n        )\n        resolutiondate = (\n            fields.get(\"resolutiondate\")\n            if isinstance(fields.get(\"resolutiondate\"), str)\n            else None\n        )\n        parent = (\n            fields.get(\"parent\") if isinstance(fields.get(\"parent\"), dict) else None\n        )\n        # Ensure subtasks is a list of dicts\n        subtasks_raw = fields.get(\"subtasks\", [])\n        subtasks = (\n            [st for st in subtasks_raw if isinstance(st, dict)]\n            if isinstance(subtasks_raw, list)\n            else []\n        )\n        security = (\n            fields.get(\"security\") if isinstance(fields.get(\"security\"), dict) else None\n        )\n        worklog = (\n            fields.get(\"worklog\") if isinstance(fields.get(\"worklog\"), dict) else None\n        )\n\n        # Lists of strings\n        labels = []\n        if labels_data := fields.get(\"labels\"):\n            if isinstance(labels_data, list):\n                labels = [str(label) for label in labels_data if label]\n\n        components = []\n        if components_data := fields.get(\"components\"):\n            if isinstance(components_data, list):\n                components = [\n                    str(comp.get(\"name\", \"\")) if isinstance(comp, dict) else str(comp)\n                    for comp in components_data\n                    if comp\n                ]\n\n        fix_versions = []\n        if fix_versions_data := fields.get(\"fixVersions\"):\n            if isinstance(fix_versions_data, list):\n                fix_versions = [\n                    str(version.get(\"name\", \"\"))\n                    if isinstance(version, dict)\n                    else str(version)\n                    for version in fix_versions_data\n                    if version\n                ]\n\n        # Handling comments\n        comments = []\n        comments_field = fields.get(\"comment\", {})\n        if isinstance(comments_field, dict) and \"comments\" in comments_field:\n            comments_data = comments_field[\"comments\"]\n            if isinstance(comments_data, list):\n                comments = [\n                    JiraComment.from_api_response(comment)\n                    for comment in comments_data\n                    if comment\n                ]\n\n        # Handling changelogs\n        changelogs = []\n        changelogs_data = data.get(\"changelog\", {})\n        if isinstance(changelogs_data, dict) and \"histories\" in changelogs_data:\n            changelogs = [\n                JiraChangelog.from_api_response(history)\n                for history in changelogs_data[\"histories\"]\n            ]\n\n        # Handling attachments\n        attachments = []\n        attachments_data = fields.get(\"attachment\", [])\n        if isinstance(attachments_data, list):\n            attachments = [\n                JiraAttachment.from_api_response(attachment)\n                for attachment in attachments_data\n                if attachment\n            ]\n\n        # Timetracking\n        timetracking = None\n        timetracking_data = fields.get(\"timetracking\")\n        if timetracking_data:\n            timetracking = JiraTimetracking.from_api_response(timetracking_data)\n\n        # URL\n        url = data.get(\"self\")  # API URL for the issue\n\n        # Try to find epic fields (varies by Jira instance)\n        epic_key = None\n        epic_name = None\n\n        # Check for \"Epic Link\" field\n        epic_link = cls._find_custom_field_in_api_response(\n            fields, [\"epic link\", \"parent epic\"]\n        )\n        if isinstance(epic_link, str):\n            epic_key = epic_link\n\n        # Check for \"Epic Name\" field\n        epic_name_value = cls._find_custom_field_in_api_response(fields, [\"epic name\"])\n        if isinstance(epic_name_value, str):\n            epic_name = epic_name_value\n\n        # Store custom fields\n        custom_fields = {}\n        fields_name_map = data.get(\"names\", {})\n        for orig_field_id, orig_field_value in fields.items():\n            if orig_field_id.startswith(\"customfield_\"):\n                value_obj_to_store = {\"value\": orig_field_value}\n                human_readable_name = fields_name_map.get(orig_field_id)\n                if human_readable_name:\n                    value_obj_to_store[\"name\"] = human_readable_name\n                custom_fields[orig_field_id] = value_obj_to_store\n\n        # Handle requested_fields parameter\n        requested_fields_param = kwargs.get(\"requested_fields\")\n\n        # Convert string requested_fields to list (except \"*all\")\n        if isinstance(requested_fields_param, str) and requested_fields_param != \"*all\":\n            requested_fields_param = requested_fields_param.split(\",\")\n            # Strip whitespace from each field name\n            requested_fields_param = [field.strip() for field in requested_fields_param]\n\n        # Create the issue instance with all the extracted data\n        return cls(\n            id=issue_id,\n            key=key,\n            summary=summary,\n            description=description,\n            created=created,\n            updated=updated,\n            status=status,\n            issue_type=issue_type,\n            priority=priority,\n            assignee=assignee,\n            reporter=reporter,\n            project=project,\n            resolution=resolution,\n            duedate=duedate,\n            resolutiondate=resolutiondate,\n            parent=parent,\n            subtasks=subtasks,\n            security=security,\n            worklog=worklog,\n            labels=labels,\n            components=components,\n            comments=comments,\n            attachments=attachments,\n            timetracking=timetracking,\n            url=url,\n            epic_key=epic_key,\n            epic_name=epic_name,\n            fix_versions=fix_versions,\n            custom_fields=custom_fields,\n            requested_fields=requested_fields_param,\n            changelogs=changelogs,\n            issuelinks=cls._extract_issue_links(fields),\n        )\n\n    def to_simplified_dict(self) -> dict[str, Any]:\n        \"\"\"Convert to simplified dictionary for API response.\"\"\"\n        result: dict[str, Any] = {\n            \"id\": self.id,\n            \"key\": self.key,\n        }\n\n        # Helper method to check if a field should be included\n        def should_include_field(field_name: str) -> bool:\n            return (\n                self.requested_fields == \"*all\"\n                or not isinstance(self.requested_fields, list)\n                or field_name in self.requested_fields\n            )\n\n        # Add summary if requested\n        if should_include_field(\"summary\"):\n            result[\"summary\"] = self.summary\n\n        # Add URL if available and requested\n        if self.url and should_include_field(\"url\"):\n            result[\"url\"] = self.url\n\n        # Add description if available and requested\n        if self.description and should_include_field(\"description\"):\n            result[\"description\"] = self.description\n\n        # Add status if available and requested\n        if self.status and should_include_field(\"status\"):\n            result[\"status\"] = self.status.to_simplified_dict()\n\n        # Add issue type if available and requested\n        if self.issue_type and should_include_field(\"issue_type\"):\n            result[\"issue_type\"] = self.issue_type.to_simplified_dict()\n\n        # Add priority if available and requested\n        if self.priority and should_include_field(\"priority\"):\n            result[\"priority\"] = self.priority.to_simplified_dict()\n\n        # Add project info if available and requested\n        if self.project and should_include_field(\"project\"):\n            result[\"project\"] = self.project.to_simplified_dict()\n\n        # Add resolution if available and requested\n        if self.resolution and should_include_field(\"resolution\"):\n            result[\"resolution\"] = self.resolution.to_simplified_dict()\n\n        # Add dates if available and requested\n        if self.duedate and should_include_field(\"duedate\"):\n            result[\"duedate\"] = self.duedate\n\n        if self.resolutiondate and should_include_field(\"resolutiondate\"):\n            result[\"resolutiondate\"] = self.resolutiondate\n\n        # Add parent and subtasks if available and requested\n        if self.parent and should_include_field(\"parent\"):\n            result[\"parent\"] = self.parent\n\n        if self.subtasks and should_include_field(\"subtasks\"):\n            result[\"subtasks\"] = self.subtasks\n\n        # Add security and worklog if available and requested\n        if self.security and should_include_field(\"security\"):\n            result[\"security\"] = self.security\n\n        if self.worklog and should_include_field(\"worklog\"):\n            result[\"worklog\"] = self.worklog\n\n        # Add assignee if requested\n        if should_include_field(\"assignee\"):\n            if self.assignee:\n                result[\"assignee\"] = self.assignee.to_simplified_dict()\n            else:\n                result[\"assignee\"] = {\"display_name\": \"Unassigned\"}\n\n        # Add reporter if available and requested\n        if self.reporter and should_include_field(\"reporter\"):\n            result[\"reporter\"] = self.reporter.to_simplified_dict()\n\n        # Add lists if available and requested\n        if self.labels and should_include_field(\"labels\"):\n            result[\"labels\"] = self.labels\n\n        if self.components and should_include_field(\"components\"):\n            result[\"components\"] = self.components\n\n        if self.fix_versions and should_include_field(\"fix_versions\"):\n            result[\"fix_versions\"] = self.fix_versions\n\n        # Add epic fields if available and requested\n        if self.epic_key and should_include_field(\"epic_key\"):\n            result[\"epic_key\"] = self.epic_key\n\n        if self.epic_name and should_include_field(\"epic_name\"):\n            result[\"epic_name\"] = self.epic_name\n\n        # Add time tracking if available and requested\n        if self.timetracking and should_include_field(\"timetracking\"):\n            result[\"timetracking\"] = self.timetracking.to_simplified_dict()\n\n        # Add created and updated timestamps if available and requested\n        if self.created and should_include_field(\"created\"):\n            result[\"created\"] = self.created\n\n        if self.updated and should_include_field(\"updated\"):\n            result[\"updated\"] = self.updated\n\n        # Add comments if available and requested\n        if self.comments and should_include_field(\"comment\"):\n            result[\"comments\"] = [\n                comment.to_simplified_dict() for comment in self.comments\n            ]\n\n        # Add attachments if available and requested\n        if self.attachments and should_include_field(\"attachment\"):\n            result[\"attachments\"] = [\n                attachment.to_simplified_dict() for attachment in self.attachments\n            ]\n\n        # Not use should_include_field since you won't get changelogs\n        # if you don't ask for them\n        if self.changelogs:\n            result[\"changelogs\"] = [\n                changelog.to_simplified_dict() for changelog in self.changelogs\n            ]\n\n        # Add issue links if available and requested\n        if self.issuelinks and should_include_field(\"issuelinks\"):\n            result[\"issuelinks\"] = [\n                link.to_simplified_dict() for link in self.issuelinks\n            ]\n\n        # Process custom fields\n        if self.custom_fields:\n            if self.requested_fields == \"*all\":\n                for internal_id, field_data_obj in self.custom_fields.items():\n                    processed_value = self._process_custom_field_value(\n                        field_data_obj.get(\"value\")\n                    )\n                    output_value_obj = {\"value\": processed_value}\n                    if \"name\" in field_data_obj:\n                        output_value_obj[\"name\"] = field_data_obj[\"name\"]\n                    result[internal_id] = output_value_obj\n            elif isinstance(self.requested_fields, list):\n                for requested_key_or_name in self.requested_fields:\n                    found_by_id_or_name = False\n                    if (\n                        requested_key_or_name.startswith(\"customfield_\")\n                        and requested_key_or_name in self.custom_fields\n                    ):\n                        field_data_obj = self.custom_fields[requested_key_or_name]\n                        output_value_obj = {\n                            \"value\": self._process_custom_field_value(\n                                field_data_obj.get(\"value\")\n                            )\n                        }\n                        if \"name\" in field_data_obj:\n                            output_value_obj[\"name\"] = field_data_obj[\"name\"]\n                        result[requested_key_or_name] = output_value_obj\n                        found_by_id_or_name = True\n                    else:\n                        for internal_id, field_data_obj in self.custom_fields.items():\n                            if (\n                                field_data_obj.get(\"name\", \"\").lower()\n                                == requested_key_or_name.lower()\n                            ):\n                                output_value_obj = {\n                                    \"value\": self._process_custom_field_value(\n                                        field_data_obj.get(\"value\")\n                                    )\n                                }\n                                output_value_obj[\"name\"] = field_data_obj[\"name\"]\n                                result[internal_id] = output_value_obj\n                                found_by_id_or_name = True\n                                break\n                    if not found_by_id_or_name and requested_key_or_name.startswith(\n                        \"cf_\"\n                    ):\n                        full_id = \"customfield_\" + requested_key_or_name[3:]\n                        if full_id in self.custom_fields:\n                            field_data_obj = self.custom_fields[full_id]\n                            output_value_obj = {\n                                \"value\": self._process_custom_field_value(\n                                    field_data_obj.get(\"value\")\n                                )\n                            }\n                            if \"name\" in field_data_obj:\n                                output_value_obj[\"name\"] = field_data_obj[\"name\"]\n                            result[full_id] = output_value_obj\n\n        return {k: v for k, v in result.items() if v is not None}\n\n    def _process_custom_field_value(self, field_value: Any) -> Any:\n        \"\"\"\n        Process a custom field value for simplified dict output.\n\n        Args:\n            field_value: The value to process\n\n        Returns:\n            Processed value suitable for API response\n        \"\"\"\n        if field_value is None or isinstance(field_value, str | int | float | bool):\n            return field_value\n\n        if isinstance(field_value, dict):\n            # For single-select, user pickers, etc., try to extract 'value' or 'name'\n            if \"value\" in field_value:\n                return field_value[\"value\"]\n            elif \"name\" in field_value:\n                return field_value[\"name\"]\n            return field_value\n\n        if isinstance(field_value, list):\n            return [self._process_custom_field_value(item) for item in field_value]\n\n        return str(field_value)\n\n    def _find_custom_field_in_issue(\n        self, name: str, pattern: bool = False\n    ) -> tuple[str | None, Any]:\n        \"\"\"\n        Find a custom field by name or pattern in an instantiated JiraIssue.\n\n        Used by instance methods like _get_epic_name and _get_epic_link\n        to search through the custom_fields dictionary of an existing issue.\n\n        Args:\n            name: The name to search for\n            pattern: If True, use regex pattern matching\n\n        Returns:\n            A tuple of (field_id, field_value) or (None, None) if not found\n        \"\"\"\n        if not self.custom_fields:\n            return None, None\n\n        # Check if fields has a names() method (some implementations have this)\n        names_dict = self.custom_fields.get(\"names\", {})\n        if isinstance(names_dict, dict):\n            for field_id, field_name in names_dict.items():\n                if (pattern and re.search(name, field_name, re.IGNORECASE)) or (\n                    not pattern and field_name.lower() == name.lower()\n                ):\n                    return field_id, self.custom_fields.get(field_id)\n        else:\n            logger.debug(\"No names dict found in custom fields\", exc_info=True)\n\n        # Check field metadata for name (custom fields usually have a name)\n        for field_id, field_value in self.custom_fields.items():\n            if not field_id.startswith(\"customfield_\"):\n                continue\n\n            # Custom fields can have a schema with a name\n            if isinstance(field_value, dict) and field_value.get(\"name\"):\n                field_name = field_value.get(\"name\")\n                if field_name and (\n                    (pattern and re.search(name, field_name, re.IGNORECASE))\n                    or (not pattern and field_name.lower() == name.lower())\n                ):\n                    return field_id, field_value\n\n        # Fallback: Directly look for keys that match the pattern\n        if pattern:\n            for field_id, field_value in self.custom_fields.items():\n                if re.search(name, field_id, re.IGNORECASE):\n                    return field_id, field_value\n\n        return None, None\n\n    def _get_epic_name(self) -> str | None:\n        \"\"\"Get the epic name from custom fields if available.\"\"\"\n        # Try each pattern in order\n        for pattern in EPIC_NAME_PATTERNS:\n            field_id, field_value = self._find_custom_field_in_issue(\n                pattern, pattern=True\n            )\n            if field_id and field_value:\n                if isinstance(field_value, dict):\n                    return field_value.get(\"value\") or field_value.get(\"name\")\n                return str(field_value)\n        return None\n\n    def _get_epic_link(self) -> str | None:\n        \"\"\"Get the epic link from custom fields if available.\"\"\"\n        # Try each pattern in order\n        for pattern in EPIC_LINK_PATTERNS:\n            field_id, field_value = self._find_custom_field_in_issue(\n                pattern, pattern=True\n            )\n            if field_id and field_value:\n                # Handle different possible value types\n                if isinstance(field_value, dict):\n                    return field_value.get(\"key\") or field_value.get(\"value\")\n                return str(field_value)\n        return None\n\n    @staticmethod\n    def _extract_issue_links(fields: dict[str, Any]) -> list[JiraIssueLink]:\n        \"\"\"\n        Extract issue links from fields.\n\n        Args:\n            fields: The fields dictionary from the Jira API\n\n        Returns:\n            List of JiraIssueLink objects\n        \"\"\"\n        if not fields or not isinstance(fields, dict):\n            return []\n\n        issuelinks_data = fields.get(\"issuelinks\", [])\n        if not isinstance(issuelinks_data, list):\n            return []\n\n        return [\n            JiraIssueLink.from_api_response(link_data)\n            for link_data in issuelinks_data\n            if link_data\n        ]\n